name: Build for PaaS Deployment

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm install
      
      - name: Build frontend
        run: npm run build
      
      - name: Generate asset manifest
        run: node scripts/generate-asset-manifest.js
      
      - name: Verify assets manifest
        run: |
          if [ ! -f "assets-manifest.json" ]; then
            echo "âŒ Error: assets-manifest.json not found"
            exit 1
          fi
          echo "âœ… assets-manifest.json exists"
          echo "Files in manifest: $(cat assets-manifest.json | jq '.files | length')"
      
      - name: Create minimal wrangler.toml for building
        run: |
          cat > wrangler.toml <<EOF
          name = "openshop-build"
          main = "src/worker.js"
          compatibility_date = "2024-09-23"
          compatibility_flags = ["nodejs_compat"]
          
          # Static assets (automatically creates ASSETS binding)
          [assets]
          directory = "dist"
          binding = "ASSETS"
          EOF
      
      - name: Build worker bundle with wrangler
        run: |
          # Wrangler builds the worker before deploying, so we can capture the build output
          # even if deployment fails due to missing auth. We'll use --outdir to control output location.
          set +e  # Don't exit on error - we want to capture the build even if deploy fails
          
          # Try to build with --dry-run first (may still require auth, but builds first)
          npx wrangler deploy --dry-run --outdir .wrangler/build 2>&1 | tee wrangler-build.log || true
          
          # If --dry-run didn't work, try regular deploy with --outdir (builds before auth check)
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Trying regular deploy to capture build output..."
            mkdir -p .wrangler/build
            npx wrangler deploy --outdir .wrangler/build --name openshop-build-temp 2>&1 | tee wrangler-build.log || true
          fi
          
          # Wrangler also builds to .wrangler/tmp/deploy-* by default
          # Find the most recently created worker.js file
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Looking for worker.js in wrangler temp directories..."
            # Use ls -t to sort by modification time (most recent first)
            WORKER_FILE=$(find .wrangler/tmp -name "worker.js" -type f 2>/dev/null | xargs ls -t 2>/dev/null | head -n 1)
            if [ -n "$WORKER_FILE" ] && [ -f "$WORKER_FILE" ]; then
              echo "Found worker.js in temp directory: $WORKER_FILE"
              cp "$WORKER_FILE" .wrangler/build/worker.js
            fi
          fi
          
          # Verify we have the built file
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Error: Could not find built worker.js file"
            echo "Wrangler build log:"
            cat wrangler-build.log || true
            echo ""
            echo "Listing .wrangler directory structure:"
            find .wrangler -type f -name "*.js" | head -20 || true
            exit 1
          fi
          
          echo "âœ… Found built worker.js"
          ls -lh .wrangler/build/worker.js
          
          # Ensure dist directory exists
          mkdir -p dist
          
          # Copy the built worker to dist/worker.bundle.js
          cp .wrangler/build/worker.js dist/worker.bundle.js
          
          # Post-process to replace node: imports with polyfilled implementations
          # Wrangler leaves node: imports expecting runtime resolution, but we need to inline them
          echo "Post-processing worker bundle to resolve node: imports..."
          
          # Create a Node.js script to process the bundle
          cat > /tmp/process-bundle.js << 'PROCESS_SCRIPT'
          const fs = require('fs');
          const path = process.argv[1];
          const bundlePath = process.argv[2] || 'dist/worker.bundle.js';
          
          let content = fs.readFileSync(bundlePath, 'utf8');
          
          // Replace node:stream imports - unenv provides Writable polyfill
          // The code only needs to instantiate Writable, so a minimal class works
          const writablePolyfill = '// node:stream polyfill - Writable class for unenv console polyfill\n' +
            'var Writable = class {\n' +
            '  constructor() {}\n' +
            '  write() { return true; }\n' +
            '  end() { return this; }\n' +
            '  on() { return this; }\n' +
            '  once() { return this; }\n' +
            '  emit() { return false; }\n' +
            '  removeListener() { return this; }\n' +
            '};';
          content = content.replace(
            /import\s+\{\s*Writable\s*\}\s+from\s+["']node:stream["'];?/g,
            writablePolyfill
          );
          
          // Replace node:events imports - unenv provides EventEmitter polyfill
          const eventEmitterPolyfill = '// node:events polyfill - EventEmitter class for unenv\n' +
            'var EventEmitter = class {\n' +
            '  constructor() {}\n' +
            '  on() { return this; }\n' +
            '  once() { return this; }\n' +
            '  emit() { return false; }\n' +
            '  removeListener() { return this; }\n' +
            '  addListener() { return this; }\n' +
            '};';
          content = content.replace(
            /import\s+\{\s*EventEmitter\s*\}\s+from\s+["']node:events["'];?/g,
            eventEmitterPolyfill
          );
          
          // Replace any other node: imports with empty objects (they should be polyfilled by unenv)
          content = content.replace(
            /import\s+.*\s+from\s+["']node:[^"']+["'];?/g,
            '// node: import removed - polyfilled by unenv'
          );
          
          fs.writeFileSync(bundlePath, content, 'utf8');
          console.log('âœ… Post-processed worker bundle');
          PROCESS_SCRIPT
          
          # Run the post-processing script
          node /tmp/process-bundle.js dist/worker.bundle.js
          
          # Verify no node: imports remain
          if grep -q 'from "node:' dist/worker.bundle.js || grep -q "from 'node:" dist/worker.bundle.js; then
            echo "âš ï¸  Warning: Some node: imports may still remain"
            grep -n 'from "node:' dist/worker.bundle.js || grep -n "from 'node:" dist/worker.bundle.js || true
          else
            echo "âœ… Verified: No node: imports remain in bundle"
          fi
          
          # Add build banner comment
          VERSION=$(node -p "require('./package.json').version")
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "// Worker Bundle - Built ${BUILD_DATE}" > dist/worker.bundle.js.tmp
          echo "// Version: ${VERSION}" >> dist/worker.bundle.js.tmp
          echo "// Built with wrangler (nodejs_compat enabled, node: imports resolved)" >> dist/worker.bundle.js.tmp
          cat dist/worker.bundle.js >> dist/worker.bundle.js.tmp
          mv dist/worker.bundle.js.tmp dist/worker.bundle.js
          
          echo "âœ… Worker bundle created: dist/worker.bundle.js"
          ls -lh dist/worker.bundle.js
          
          # Verify the built worker includes nodejs_compat polyfills (unenv)
          echo ""
          echo "Verifying worker.bundle.js includes nodejs_compat polyfills..."
          if grep -q "unenv" dist/worker.bundle.js; then
            echo "âœ… Verified: worker.bundle.js includes unenv polyfills (nodejs_compat)"
          else
            echo "âš ï¸  Warning: worker.bundle.js may not include nodejs_compat polyfills"
            echo "First 50 lines of worker.bundle.js:"
            head -n 50 dist/worker.bundle.js
          fi
          
          # Show file size for reference
          echo ""
          echo "Worker bundle size:"
          du -h dist/worker.bundle.js
      
      - name: Commit built assets to repository
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -B ${{ github.ref_name }}
          
          # List dist folder contents for debugging
          echo "Contents of dist folder before commit:"
          ls -la dist/ || echo "dist folder does not exist"
          
          # Add worker bundle
          git add -f dist/worker.bundle.js
          
          # Add frontend assets (excluding worker.bundle.js which is already added)
          # Force add dist folder even though it's in .gitignore
          git add -f dist/
          
          # Show what's staged
          echo "Staged files:"
          git status --short
          
          # Commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Build: Update assets and worker bundle [skip ci]" || exit 0
            git push origin HEAD:${{ github.ref_name }}
            echo "âœ… Successfully committed and pushed built assets"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Verify build artifacts
        run: |
          echo "ðŸ” Verifying build artifacts..."
          
          # Check worker bundle exists
          if [ ! -f "dist/worker.bundle.js" ]; then
            echo "âŒ Error: dist/worker.bundle.js not found"
            exit 1
          fi
          echo "âœ… worker.bundle.js exists ($(du -h dist/worker.bundle.js | cut -f1))"
          
          # Check asset manifest exists
          if [ ! -f "dist/asset-manifest.json" ]; then
            echo "âŒ Error: dist/asset-manifest.json not found"
            exit 1
          fi
          echo "âœ… asset-manifest.json exists"
          
          # Check key static assets
          if [ ! -f "dist/index.html" ]; then
            echo "âŒ Error: dist/index.html not found"
            exit 1
          fi
          echo "âœ… index.html exists"
          
          # Count total files in dist (excluding worker.bundle.js)
          ASSET_COUNT=$(find dist -type f ! -name "worker.bundle.js" | wc -l)
          echo "âœ… Found $ASSET_COUNT static asset files"
          
          # List asset manifest contents
          echo ""
          echo "Asset manifest contents:"
          cat dist/asset-manifest.json | head -20
          
          echo ""
          echo "âœ… All build artifacts verified successfully"
      
      - name: Create build metadata
        run: |
          VERSION=$(node -p "require('./package.json').version")
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > build-info.json <<EOF
          {
            "version": "$VERSION",
            "buildDate": "$BUILD_DATE",
            "commitHash": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "ref": "${{ github.ref }}",
            "buildNumber": "${{ github.run_number }}"
          }
          EOF
          cat build-info.json
      
      - name: Prepare individual asset files for release
        run: |
          # Create a script to prepare asset files with sanitized names
          # GitHub release asset names can't contain /, so we use asset- prefix and replace / with -
          cat > /tmp/prepare-assets.js << 'ASSET_SCRIPT'
          const fs = require('fs');
          const path = require('path');
          const manifest = JSON.parse(fs.readFileSync('assets-manifest.json', 'utf8'));
          
          // Create assets directory for renamed files
          const assetsDir = 'release-assets';
          if (!fs.existsSync(assetsDir)) {
            fs.mkdirSync(assetsDir, { recursive: true });
          }
          
          // Copy each file with its sanitized name
          for (const file of manifest.files) {
            const sourcePath = path.join('dist', file.path.replace(/^\//, ''));
            const destPath = path.join(assetsDir, file.assetName);
            
            // Ensure destination directory exists
            const destDir = path.dirname(destPath);
            if (!fs.existsSync(destDir)) {
              fs.mkdirSync(destDir, { recursive: true });
            }
            
            // Copy file
            fs.copyFileSync(sourcePath, destPath);
            console.log(`Copied: ${file.path} â†’ ${file.assetName}`);
          }
          
          console.log(`âœ… Prepared ${manifest.files.length} asset files`);
          ASSET_SCRIPT
          
          node /tmp/prepare-assets.js
      
      - name: Create Release (if on main/master)
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            assets-manifest.json
            dist/worker.bundle.js
            build-info.json
            release-assets/**
          tag_name: latest
          name: Latest Build
          body: |
            Latest build artifacts for OpenShop.
            
            - assets-manifest.json: Manifest listing all asset files
            - release-assets/*: Individual asset files (one per file in dist/)
            - worker.bundle.js: Bundled worker code ready for deployment
            - build-info.json: Build metadata (version, commit hash, build date)
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Upload Worker Bundle
        uses: actions/upload-artifact@v4
        with:
          name: worker-bundle
          path: dist/worker.bundle.js
          retention-days: 30
      
      - name: Upload Frontend
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/
          retention-days: 30
      
      - name: Upload Frontend Compressed
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist-tar
          path: frontend-dist.tar.gz
          retention-days: 30
      
      - name: Upload Build Info
        uses: actions/upload-artifact@v4
        with:
          name: build-info
          path: build-info.json
          retention-days: 30

