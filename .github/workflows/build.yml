name: Build for PaaS Deployment

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm install
      
      - name: Build frontend
        run: npm run build
      
      - name: Generate asset manifest
        run: node scripts/generate-asset-manifest.js
      
      - name: Verify assets manifest
        run: |
          if [ ! -f "assets-manifest.json" ]; then
            echo "‚ùå Error: assets-manifest.json not found"
            exit 1
          fi
          echo "‚úÖ assets-manifest.json exists"
          echo "Files in manifest: $(cat assets-manifest.json | jq '.files | length')"
      
      - name: Create minimal wrangler.toml for building
        run: |
          cat > wrangler.toml <<EOF
          name = "openshop-build"
          main = "src/worker.js"
          compatibility_date = "2024-09-23"
          compatibility_flags = ["nodejs_compat"]
          
          # Static assets (automatically creates ASSETS binding)
          [assets]
          directory = "dist"
          binding = "ASSETS"
          EOF
      
      - name: Build worker bundle with wrangler
        run: |
          # Wrangler builds the worker before deploying, so we can capture the build output
          # even if deployment fails due to missing auth. We'll use --outdir to control output location.
          set +e  # Don't exit on error - we want to capture the build even if deploy fails
          
          # Try to build with --dry-run first (may still require auth, but builds first)
          npx wrangler deploy --dry-run --outdir .wrangler/build 2>&1 | tee wrangler-build.log || true
          
          # If --dry-run didn't work, try regular deploy with --outdir (builds before auth check)
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Trying regular deploy to capture build output..."
            mkdir -p .wrangler/build
            npx wrangler deploy --outdir .wrangler/build --name openshop-build-temp 2>&1 | tee wrangler-build.log || true
          fi
          
          # Wrangler also builds to .wrangler/tmp/deploy-* by default
          # Find the most recently created worker.js file
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Looking for worker.js in wrangler temp directories..."
            # Use ls -t to sort by modification time (most recent first)
            WORKER_FILE=$(find .wrangler/tmp -name "worker.js" -type f 2>/dev/null | xargs ls -t 2>/dev/null | head -n 1)
            if [ -n "$WORKER_FILE" ] && [ -f "$WORKER_FILE" ]; then
              echo "Found worker.js in temp directory: $WORKER_FILE"
              cp "$WORKER_FILE" .wrangler/build/worker.js
            fi
          fi
          
          # Verify we have the built file
          if [ ! -f ".wrangler/build/worker.js" ]; then
            echo "Error: Could not find built worker.js file"
            echo "Wrangler build log:"
            cat wrangler-build.log || true
            echo ""
            echo "Listing .wrangler directory structure:"
            find .wrangler -type f -name "*.js" | head -20 || true
            exit 1
          fi
          
          echo "‚úÖ Found built worker.js"
          ls -lh .wrangler/build/worker.js
          
          # Ensure dist directory exists
          mkdir -p dist
          
          # Copy the built worker to dist/worker.bundle.js
          cp .wrangler/build/worker.js dist/worker.bundle.js
          
          # Post-process to replace node: imports with polyfilled implementations
          # Wrangler leaves node: imports expecting runtime resolution, but we need to inline them
          echo "Post-processing worker bundle to resolve node: imports..."
          
          # Create a Node.js script to process the bundle
          cat > /tmp/process-bundle.js << 'PROCESS_SCRIPT'
          const fs = require('fs');
          const path = process.argv[1];
          const bundlePath = process.argv[2] || 'dist/worker.bundle.js';
          
          let content = fs.readFileSync(bundlePath, 'utf8');
          
          // Replace node:stream imports - unenv provides Writable polyfill
          // The code only needs to instantiate Writable, so a minimal class works
          const writablePolyfill = '// node:stream polyfill - Writable class for unenv console polyfill\n' +
            'var Writable = class {\n' +
            '  constructor() {}\n' +
            '  write() { return true; }\n' +
            '  end() { return this; }\n' +
            '  on() { return this; }\n' +
            '  once() { return this; }\n' +
            '  emit() { return false; }\n' +
            '  removeListener() { return this; }\n' +
            '};';
          content = content.replace(
            /import\s+\{\s*Writable\s*\}\s+from\s+["']node:stream["'];?/g,
            writablePolyfill
          );
          
          // Replace node:events imports - unenv provides EventEmitter polyfill
          const eventEmitterPolyfill = '// node:events polyfill - EventEmitter class for unenv\n' +
            'var EventEmitter = class {\n' +
            '  constructor() {}\n' +
            '  on() { return this; }\n' +
            '  once() { return this; }\n' +
            '  emit() { return false; }\n' +
            '  removeListener() { return this; }\n' +
            '  addListener() { return this; }\n' +
            '};';
          content = content.replace(
            /import\s+\{\s*EventEmitter\s*\}\s+from\s+["']node:events["'];?/g,
            eventEmitterPolyfill
          );
          
          // Replace any other node: imports with empty objects (they should be polyfilled by unenv)
          content = content.replace(
            /import\s+.*\s+from\s+["']node:[^"']+["'];?/g,
            '// node: import removed - polyfilled by unenv'
          );
          
          fs.writeFileSync(bundlePath, content, 'utf8');
          console.log('‚úÖ Post-processed worker bundle');
          PROCESS_SCRIPT
          
          # Run the post-processing script
          node /tmp/process-bundle.js dist/worker.bundle.js
          
          # Verify no node: imports remain
          if grep -q 'from "node:' dist/worker.bundle.js || grep -q "from 'node:" dist/worker.bundle.js; then
            echo "‚ö†Ô∏è  Warning: Some node: imports may still remain"
            grep -n 'from "node:' dist/worker.bundle.js || grep -n "from 'node:" dist/worker.bundle.js || true
          else
            echo "‚úÖ Verified: No node: imports remain in bundle"
          fi
          
          # Add build banner comment
          VERSION=$(node -p "require('./package.json').version")
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "// Worker Bundle - Built ${BUILD_DATE}" > dist/worker.bundle.js.tmp
          echo "// Version: ${VERSION}" >> dist/worker.bundle.js.tmp
          echo "// Built with wrangler (nodejs_compat enabled, node: imports resolved)" >> dist/worker.bundle.js.tmp
          cat dist/worker.bundle.js >> dist/worker.bundle.js.tmp
          mv dist/worker.bundle.js.tmp dist/worker.bundle.js
          
          echo "‚úÖ Worker bundle created: dist/worker.bundle.js"
          ls -lh dist/worker.bundle.js
          
          # Verify the built worker includes nodejs_compat polyfills (unenv)
          echo ""
          echo "Verifying worker.bundle.js includes nodejs_compat polyfills..."
          if grep -q "unenv" dist/worker.bundle.js; then
            echo "‚úÖ Verified: worker.bundle.js includes unenv polyfills (nodejs_compat)"
          else
            echo "‚ö†Ô∏è  Warning: worker.bundle.js may not include nodejs_compat polyfills"
            echo "First 50 lines of worker.bundle.js:"
            head -n 50 dist/worker.bundle.js
          fi
          
          # Show file size for reference
          echo ""
          echo "Worker bundle size:"
          du -h dist/worker.bundle.js
      
      - name: Commit built assets to repository
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -B ${{ github.ref_name }}
          
          # List dist folder contents for debugging
          echo "Contents of dist folder before commit:"
          ls -la dist/ || echo "dist folder does not exist"
          
          # Add worker bundle
          git add -f dist/worker.bundle.js
          
          # Add frontend assets (excluding worker.bundle.js which is already added)
          # Force add dist folder even though it's in .gitignore
          git add -f dist/
          
          # Show what's staged
          echo "Staged files:"
          git status --short
          
          # Commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Build: Update assets and worker bundle [skip ci]" || exit 0
            git push origin HEAD:${{ github.ref_name }}
            echo "‚úÖ Successfully committed and pushed built assets"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Verify build artifacts
        run: |
          echo "üîç Verifying build artifacts..."
          
          # Check worker bundle exists
          if [ ! -f "dist/worker.bundle.js" ]; then
            echo "‚ùå Error: dist/worker.bundle.js not found"
            exit 1
          fi
          echo "‚úÖ worker.bundle.js exists ($(du -h dist/worker.bundle.js | cut -f1))"
          
          # Check asset manifest exists
          if [ ! -f "dist/asset-manifest.json" ]; then
            echo "‚ùå Error: dist/asset-manifest.json not found"
            exit 1
          fi
          echo "‚úÖ asset-manifest.json exists"
          
          # Check key static assets
          if [ ! -f "dist/index.html" ]; then
            echo "‚ùå Error: dist/index.html not found"
            exit 1
          fi
          echo "‚úÖ index.html exists"
          
          # Count total files in dist (excluding worker.bundle.js)
          ASSET_COUNT=$(find dist -type f ! -name "worker.bundle.js" | wc -l)
          echo "‚úÖ Found $ASSET_COUNT static asset files"
          
          # List asset manifest contents
          echo ""
          echo "Asset manifest contents:"
          cat dist/asset-manifest.json | head -20
          
          echo ""
          echo "‚úÖ All build artifacts verified successfully"
      
      - name: Create build metadata
        run: |
          VERSION=$(node -p "require('./package.json').version")
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          cat > build-info.json <<EOF
          {
            "version": "$VERSION",
            "buildDate": "$BUILD_DATE",
            "commitHash": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "ref": "${{ github.ref }}",
            "buildNumber": "${{ github.run_number }}"
          }
          EOF
          cat build-info.json
      
      - name: Prepare individual asset files for release
        run: |
          # Create a script to prepare asset files with sanitized names
          # GitHub release asset names can't contain /, so we use asset- prefix and replace / with -
          cat > /tmp/prepare-assets.js << 'ASSET_SCRIPT'
          const fs = require('fs');
          const path = require('path');
          const manifest = JSON.parse(fs.readFileSync('assets-manifest.json', 'utf8'));
          
          // Create assets directory for renamed files
          const assetsDir = 'release-assets';
          if (!fs.existsSync(assetsDir)) {
            fs.mkdirSync(assetsDir, { recursive: true });
          }
          
          // Copy each file with its sanitized name
          const fileList = [];
          for (const file of manifest.files) {
            const sourcePath = path.join('dist', file.path.replace(/^\//, ''));
            const destPath = path.join(assetsDir, file.assetName);
            
            // Ensure destination directory exists
            const destDir = path.dirname(destPath);
            if (!fs.existsSync(destDir)) {
              fs.mkdirSync(destDir, { recursive: true });
            }
            
            // Copy file
            fs.copyFileSync(sourcePath, destPath);
            fileList.push(destPath);
            console.log(`Copied: ${file.path} ‚Üí ${file.assetName}`);
          }
          
          // Write file list for release action
          fs.writeFileSync('release-assets-list.txt', fileList.join('\n'), 'utf8');
          console.log(`‚úÖ Prepared ${manifest.files.length} asset files`);
          console.log(`‚úÖ Created release-assets-list.txt with ${fileList.length} files`);
          ASSET_SCRIPT
          
          node /tmp/prepare-assets.js
      
      - name: Verify release assets exist
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        run: |
          echo "Verifying files exist before release creation..."
          echo ""
          echo "Checking assets-manifest.json:"
          ls -lh assets-manifest.json || echo "‚ùå assets-manifest.json not found"
          echo ""
          echo "Checking dist/worker.bundle.js:"
          ls -lh dist/worker.bundle.js || echo "‚ùå dist/worker.bundle.js not found"
          echo ""
          echo "Checking build-info.json:"
          ls -lh build-info.json || echo "‚ùå build-info.json not found"
          echo ""
          echo "Checking release-assets directory:"
          ls -lh release-assets/ | head -20 || echo "‚ùå release-assets directory not found"
          echo ""
          echo "Total files in release-assets: $(find release-assets -type f | wc -l)"
          echo ""
          echo "Sample asset files:"
          find release-assets -type f | head -10
      
      - name: Create Release (if on main/master)
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        run: |
          # Create a file list for the release
          echo "assets-manifest.json" > release-files-list.txt
          echo "dist/worker.bundle.js" >> release-files-list.txt
          echo "build-info.json" >> release-files-list.txt
          
          # Add all asset files from the list
          while IFS= read -r file; do
            if [ -f "$file" ]; then
              echo "$file" >> release-files-list.txt
            else
              echo "‚ö†Ô∏è  Warning: File not found: $file"
            fi
          done < release-assets-list.txt
          
          FILE_COUNT=$(wc -l < release-files-list.txt)
          echo "Total files to upload: $FILE_COUNT"
          echo ""
          echo "Sample files:"
          head -10 release-files-list.txt
          echo ""
          
          # Delete existing release if it exists
          if gh release view latest >/dev/null 2>&1; then
            echo "Release 'latest' already exists, deleting..."
            gh release delete latest --yes || true
          fi
          
          # Create release using gh CLI with file list
          # Use xargs to handle many files properly
          cat release-files-list.txt | xargs gh release create latest \
            --title "Latest Build" \
            --notes "Latest build artifacts for OpenShop.
            
            - assets-manifest.json: Manifest listing all asset files
            - release-assets/asset-*: Individual asset files (one per file in dist/)
            - worker.bundle.js: Bundled worker code ready for deployment
            - build-info.json: Build metadata (version, commit hash, build date)" \
            --prerelease=false \
            --latest
          
          echo "‚úÖ Release created successfully with $FILE_COUNT files"
          
          # Verify release was created
          echo ""
          echo "Release assets:"
          gh release view latest --json assets --jq '.assets[].name' | head -20
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Upload Worker Bundle
        uses: actions/upload-artifact@v4
        with:
          name: worker-bundle
          path: dist/worker.bundle.js
          retention-days: 30
      
      - name: Upload Assets Manifest
        uses: actions/upload-artifact@v4
        with:
          name: assets-manifest
          path: assets-manifest.json
          retention-days: 30
      
      - name: Upload Individual Assets
        uses: actions/upload-artifact@v4
        with:
          name: release-assets
          path: release-assets/
          retention-days: 30
      
      - name: Upload Build Info
        uses: actions/upload-artifact@v4
        with:
          name: build-info
          path: build-info.json
          retention-days: 30

